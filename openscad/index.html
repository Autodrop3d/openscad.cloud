<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OpenSCAD Cloud from Autodrop3d</title>
<link rel="icon" type="image/x-icon" href="../logo.png">
<script src="./login.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SWE7HZBGBR"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-SWE7HZBGBR');
</script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<link id="mainStyleSheet" rel="stylesheet" type="text/css" href="./css/mvp.css">
<link id="mainStyleSheet" rel="stylesheet" type="text/css" href="./css/dark.css">

<script src="./stlViewer/engine/threejs/three.min.js"></script>
<script src="./stlViewer/engine/threejs/OrbitControls.js"></script>
<script src="./stlViewer/engine/threejs/STLLoader.js"></script>
<script src="./stlViewer/engine/parts/engine-render/sceneHandler.js"></script>
<script src="./stlViewer/engine/parts/engine-render/renderHandler.js"></script>
<script src='./stlViewer/engine/engine.js'></script>

<link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.20.0/min/vs/editor/editor.main.min.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.26.1/min/vs/loader.min.js"></script>


<div id="CheatSheet" style="top:10%;right:10%;left:10%;bottom:10%;position: absolute;z-index: 1000; background-color: rgb(52, 55, 55);">
    <iframe style="width:100%;height:100%;" src="https://openscad.org/cheatsheet/"></iframe>
</div>


<div id="configurator" style="top:10%;right:50%;left:10%;bottom:10%;position: absolute;z-index: 1000; background-color: rgb(52, 55, 55);overflow-y: scroll;">
    <button onclick="generate_param_string()">Generate </button>
    <div id="container"></div>
</div>

<script>
    $("#CheatSheet").hide();
    $("#configurator").hide();
</script>



<style>
    .container {
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-columns: 1.2fr 1.2fr;
        grid-template-rows: 0.1fr 0.1fr 2.3fr 0.4fr;
        gap: 0px 0px;
        grid-auto-flow: row;
        grid-template-areas:
            "toolbar1 toolbar2"
            "toolbar3 view3d"
            "openScadCode view3d"
            "openScadCode OpenScadConsole";
    }

    .toolbar1 {
        grid-area: toolbar1;
    }

    .toolbar2 {
        grid-area: toolbar2;
    }

    .toolbar3 {
        grid-area: toolbar3;
        display: inline-block;
    }

    .toolBarItem {
        display: inline-block;
    }

    .openScadCode {
        grid-area: openScadCode;
    }

    .view3d {
        grid-area: view3d;
    }

    .OpenScadConsole {
        grid-area: OpenScadConsole;
        height: 100%;
    }


    .OpenScadConsole {
        overflow: scroll;
        grid-area: OpenScadConsole;
    }



    select:focus,
    input:focus,
    textarea:focus {
        background: white;
    }

    #canvas-container {
        width: 97%;
        height: 99%;
        border: 1px solid yellow;
    }
</style>



<div class="container">
    <div class="toolbar1">
        <button onclick="goBackToPartPage()">â—„ Back to part details</button>
        <button id="Save" onclick="storeOpenSCADfileToCloud();">ðŸ’¾</button>
        <button id="runOpenSCAD">â–¶</button>
        <button onclick="download('export-'+ openPartID+openPartRev+'.stl', window.currentSTL);">Export STL</button>
        <button onclick="makeShareLink();">Share Link</button>
        <button onclick="$('#CheatSheet').toggle()">Cheat Sheet</button>
        <button onclick="parse_text_as_scad();">Customizer</button>




    </div>
    <div class="toolbar2">
        <button onclick="meshWire.visible = (meshWire.visible === true ? false : true)" style="display: inline-block;">Wireframe</button>
        <button onclick="meshSolid.visible = (meshSolid.visible === true ? false : true)" style="display: inline-block;">Solid</button>
        <input id="transparancy" type="range" min=".1" max="1" step=".05" value=".9" oninput="meshSolid.material.opacity = this.value;" style="display: inline-block;height:22px;">

        <button onclick="doLogin();" style="float:right;">Login</button>

    </div>
    <div class="toolbar3">

        <select id="fileSelector" class="toolBarItem">
            <option>main.scad</option>
        </select>
        <button onclick="createFile();" class="toolBarItem">ï¼‹</button>
        <button onclick="deleteFile();" class="toolBarItem">ðŸ—‘</button>
        <button onclick="renameFile();" class="toolBarItem">Rename</button>

    </div>
    <div class="openScadCode">
        <div id="monacoEditor" style="height:100%;width:100%;  resize: horizontal;"></div>
    </div>
    <div class="view3d">
        <div id="canvas-container"></div>
    </div>
    <div class="OpenScadConsole">
        <pre id="consoleOutput"></pre>
    </div>
</div>



<div id="globalDimmScreen" class="modal" onclick="if(event.target.id =='globalModalWindow') ModalWindowClose();">
    <div class="modal" style="display: block;background:url(./images/loading.gif) center center no-repeat;">
    </div>
</div>








<script>
    apiDomainName = "https://go.autodrop3d.com/";
    credits = `Credits and acknowledgements:  
<a href="https://github.com/DSchroer/openscad-wasm" target="_blank">DSchroer: OpenSCAD wasm port</a>
<a href="https://github.com/ochafik/openscad-wasm/blob/editor-ochafik.com/example/www/openscad-editor-config.js" target="_blank">ochafik: Code highlighting </a>  
`
    function param(name) {
        return (location.search.split(name + '=')[1] || '').split('&')[0];
    }


    openPartID = param("openPartID");
    openPartRev = param("openPartRev");
    sharedFileLink = param("sharedFileLink");
    CurrentOrgID = "";

    configuratorString = "";



    window.firstRenderDone = false;

    async function doAjax(apiToCall, args) {
        //reset alert field
        $("#alert").html("");

        let result;

        try {
            headersToken = 'Bearer ' + JSON.parse(localStorage.getItem("userKey")).user.token;
        }
        catch (error) {
            headersToken = "";
        }

        //alert("showing loading screen");
        $("#globalDimmScreen").show();

        try {
            result = await $.ajax({
                url: apiDomainName + apiToCall,
                dataType: 'json',
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(args),
                processData: false,
                headers: { "Authorization": headersToken },
            });
            //console.log(result);
            $("#globalDimmScreen").hide();
            return result;

        }
        catch (error) {
            console.error(error);
            errorJson = error.responseJSON.message;
            ajaxError = errorJson;
            console.log(ajaxError);
            $("#alert").html("Error: " + ajaxError);
        };

        $("#globalDimmScreen").hide();
    }


    $(function () {
        $('#openScadCodeCodeEditorTextArea').on('keydown', function (e) {
            if (e.keyCode == 9 || e.which == 9) {
                e.preventDefault();
                var s = this.selectionStart;
                $(this).val(function (i, v) {
                    return v.substring(0, s) + "\t" + v.substring(this.selectionEnd)
                });
                this.selectionEnd = s + 1;
            }
        });
    });

    async function storeOpenSCADfileToCloud() {
        response = await doAjax('../api/cadFiles/storeCadModelOpenSCAD', {
            id: openPartID,
            rev: openPartRev,
            modelFile: JSON.stringify(virtualFileSystem),
            stlFile: window.currentSTL

        });

        if (response == undefined) {
            alert("save failed");
            CurrentUserID = await JSON.parse(await localStorage.getItem("userKey")).user._id;

            //const usersGroups = (await doAjax('../api/organizations/usersOrg', { userID: CurrentUserID }))[0]._id;
            //alert(await JSON.stringify(usersGroups));
            CurrentOrgID = (await doAjax('../api/organizations/usersOrg', { userID: CurrentUserID }))[0]._id;
            await createNewPart();
            storeOpenSCADfileToCloud();

        } else {
            alert(JSON.stringify(response));
        }


    }

    async function createNewPart() {
        partsQuery = {
            Name: "New Part Name",
            organizationID: CurrentOrgID
        };

        partsQuery.Name = prompt("Enter new part name", partsQuery.Name);

        if (partsQuery.Name == null) return;

        const makingThatNewPart = await doAjax('../api/cadFiles/create', partsQuery);

        openPartRev = 1;
        openPartID = makingThatNewPart._id;

        //await alert(openPartID);


        try {
            propertiesToReadReturn = await JSON.parse(await doAjax('../api/cadFiles/returnProperties', {
                id: openPartID,
                rev: openPartRev,
            }));


            propertiesToReadReturn.modelingMethod = "OPENSCAD";


            propertiesToSave = {};
            propertiesToSave = {
                id: openPartID,
                rev: openPartRev,
                SettingsFile: propertiesToReadReturn
            };
            await doAjax('../api/cadFiles/storeProperties', propertiesToSave);
        } catch (err) {
            alert("Failed setting openSCAD as modeling method")
        }

    }

    var virtualFileSystem = [
        {
            name: "main.scad", txt: ""
        },
    ];

    try {
        if (sharedFileLink) {
            virtualFileSystem = JSON.parse(atob(sharedFileLink));
        }
    } catch (e) {
        console.log(e);
    }


    var currentVirtualFileName = "main.scad";



    $("#fileSelector").change(
        function () {
            showFileInEditor();
        }
    );


    async function showFileInEditor() {
        await saveCurrentFileToVirtualFileSystem();
        currentVirtualFileName = await $('#fileSelector').val() + "";
        await virtualFileSystem.forEach(async (item, index) => {
            if (item.name == currentVirtualFileName) {
                await window.editor.getModel().setValue(item.txt);
            }
        });

    }


    async function createFile() {
        await saveCurrentFileToVirtualFileSystem();
        const myNewFileName = await prompt("New file name", "newFile.scad");
        var fileExists = false;
        await virtualFileSystem.forEach(async (item, index) => {
            if (myNewFileName == item.name) fileExists = true;
        });

        if (fileExists == false) {
            await virtualFileSystem.push({ name: myNewFileName, txt: "  " });
            currentVirtualFileName = myNewFileName;
            await window.editor.getModel().setValue("");

        } else {
            alert("File with name '" + myNewFileName + "' already exists")
        }

        await updateFileSelector(myNewFileName);
        await showFileInEditor();
    }


    async function deleteFile() {

        const fileNameToRemove = currentVirtualFileName;
        if (fileNameToRemove == "main.scad") {
            alert("Can not delete 'main.scad'");
            return
        }

        var indexOfItemToRemove;
        await virtualFileSystem.forEach(async (item, index) => {
            if (item.name == fileNameToRemove) indexOfItemToRemove = index;
        });

        if (indexOfItemToRemove && await confirm("Are you sure you want to delete '" + fileNameToRemove + "'?")) {
            virtualFileSystem.splice(indexOfItemToRemove, 1);
            currentVirtualFileName = "main.scad";
        }


        updateFileSelector();
    }


    async function renameFile() {
        await saveCurrentFileToVirtualFileSystem();
        const fileNameToRename = currentVirtualFileName;
        const newFileName = prompt("New file name", fileNameToRename);

        if (newFileName) {
            await virtualFileSystem.forEach(await async function (item, index) {
                if (item.name == fileNameToRename) item.name = newFileName;
            });
            updateFileSelector(newFileName);
        }

    }


    async function updateFileSelector(fileToSelect = undefined) {
        if (fileToSelect !== undefined) {
            currentVirtualFileName = fileToSelect;
        }


        await $('#fileSelector').children().remove();
        await virtualFileSystem.forEach(async (item, index) => {
            await $('#fileSelector').append(await $('<option>', {
                value: item.name,
                text: item.name,
            }));
        });
        //await $('#fileSelector').val(currentVirtualFileName);
        document.getElementById("fileSelector").value = currentVirtualFileName;//= currentVirtualFileName;
        //alert(await $('#fileSelector').val());
    }

    updateFileSelector();



    async function saveCurrentFileToVirtualFileSystem() {
        await virtualFileSystem.forEach(async (item, index) => {

            if (item.name == currentVirtualFileName) {

                item.txt = await window.editor.getValue();
                //alert(item.txt)
            }
        });
    }




    async function makeShareLink() {
        const stringForURL = await btoa(await JSON.stringify(virtualFileSystem));
        copyToClipboard("https://" + window.location.hostname + window.location.pathname + "?&sharedFileLink=" + stringForURL);
    }


    function copyToClipboard(text) {
        var dummy = document.createElement("textarea");
        // to avoid breaking orgain page when copying more words
        // cant copy when adding below this code
        // dummy.style.display = 'none'
        document.body.appendChild(dummy);
        //Be careful if you use texarea. setAttribute('value', value), which works with "input" does not work with "textarea". â€“ Eduard
        dummy.value = text;
        dummy.select();
        document.execCommand("copy");
        document.body.removeChild(dummy);
        alert("Text copied to clip board.");
    }

    async function goBackToPartPage() {
        urlForTheBrowserWindow = "https://autodrop.cloud" +
            "/?" +
            "&CurrentBodyDiv=CurrentToolBarDiv=part" +
            "&CurrentToolBarDiv=part" +
            "&currentDivs=part" +
            "&openPartID=" + openPartID +
            "&openPartRev=" + openPartRev;
        //alert(urlForTheBrowserWindow);
        window.location.href = urlForTheBrowserWindow;
    }

    var meshWire;
    var meshSolid;
    Engine.createScene({ containerId: 'canvas-container', showGrid: false });

    async function ShowMeThatStinkingStlFile(currentSTL) {
        window.currentSTL = currentSTL;
        SceneHandler.getScene("scene-0").scene.children = [SceneHandler.getScene("scene-0").scene.children[0]];

        const loader = await new THREE.STLLoader;
        var geometry = await loader.parse(currentSTL);

        //check old mesh setting visibility
        let oldMeshSettings = {
            meshWire: {},
            meshSolid: {},
        };
        try {
            oldMeshSettings.meshWire.visible = meshWire.visible;
            oldMeshSettings.meshSolid.visible = meshSolid.visible;
            oldMeshSettings.meshSolid.opacity = meshSolid.material.opacity;
            oldMeshSettings = await JSON.parse(await JSON.stringify(oldMeshSettings));

        } catch (e) {
            console.log(e);
            oldMeshSettings = undefined;
        }
        //alert(JSON.stringify(oldMeshSettings));


        meshWire = await new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, }));
        meshSolid = await new THREE.Mesh(geometry, new THREE.MeshNormalMaterial({ transparent: true, opacity: .95 }));

        if (oldMeshSettings) {

            meshWire.visible = oldMeshSettings.meshWire.visible;
            meshSolid.visible = oldMeshSettings.meshSolid.visible;
            meshSolid.material.opacity = oldMeshSettings.meshSolid.opacity;
        }

        meshWire.rotateX(-Math.PI / 2);
        meshSolid.rotateX(-Math.PI / 2);

        var box = await new THREE.Box3().setFromObject(meshSolid);
        meshTranslationInY = box.getSize().y / 2;
        meshWire.translateZ(meshTranslationInY);
        meshSolid.translateZ(meshTranslationInY);



        await Engine.addToScene(meshWire, 'scene-0');
        await Engine.addToScene(meshSolid, 'scene-0');
        window.firstRenderDone = true;
    }

    function download(filename, text) {
        var element = document.createElement('a');
        element.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(text);
        element.download = filename;
        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

</script>





<script type="module">
    import OpenScad from "./openscad.js";
    import { addFonts } from "./openscad.fonts.js";

    import { registerOpenSCADLanguage } from './openscad-editor-config.js'

    async function setUpMonacoEditor() {
        await require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.26.1/min/vs' } });



        let codeFromServerSide = await doAjax('../api/cadFiles/returnCadModelOpenSCAD', {
            id: openPartID, rev: openPartRev
        });
        if (codeFromServerSide !== undefined) {
            try {
                virtualFileSystem = await JSON.parse(codeFromServerSide);
            } catch (e) {
                virtualFileSystem[0].txt = codeFromServerSide;
            }
        }
        await updateFileSelector("main.scad");
        //await showFileInEditor();
        await require(["vs/editor/editor.main"], async () => {
            await registerOpenSCADLanguage();
            window.editor = await monaco.editor.create(document.getElementById('monacoEditor'), {
                value: virtualFileSystem[0].txt,
                language: 'openscad',
                theme: 'vs-dark',
            });
        });

        window.firstRenderDone == true;
    }

    await setUpMonacoEditor();







    const openSCADconsoleOutput = document.getElementById("consoleOutput");


    async function runAndShowScad() {
        await saveCurrentFileToVirtualFileSystem();
        openSCADconsoleOutput.innerHTML = "" + credits;
        $("#globalDimmScreen").show();
        try {
            const instance = await OpenScad({
                noInitialRun: true,
                'print': text => {
                    openSCADconsoleOutput.innerHTML += text + "\n";
                },
                'printErr': text => {
                    openSCADconsoleOutput.innerHTML += text + "\n";
                },
            });

            addFonts(instance);

            await virtualFileSystem.forEach(async (item, index) => {
                await instance.FS.writeFile("/" + item.name, item.txt);
            });



            window.firstRenderDone == true;

            let openSCADarguments = [];
            openSCADarguments.push("/main.scad");
            openSCADarguments.push("-o");
            openSCADarguments.push("cube.stl");

            if (configuratorString !== "") {
                openSCADarguments.push("--enable=customizer");
                openSCADarguments.push("-p");
                openSCADarguments.push("/custom.json");
                await instance.FS.writeFile("/custom.json", configuratorString);

            }

            console.log(await instance.callMain(openSCADarguments));
            const output = await new Blob([await instance.FS.readFile("/cube.stl")]).text();
            ShowMeThatStinkingStlFile(output);
        } catch (e) {
            console.log(e);
            openSCADconsoleOutput.innerHTML += e;


            if (e == "TypeError: Cannot read properties of undefined (reading 'getValue')") {
                setTimeout(runAndShowScad(), 3000)
            }
        }

        $("#globalDimmScreen").hide();
    }

    //await runAndShowScad();
    document.getElementById("runOpenSCAD").onclick = function () { runAndShowScad() };
</script>



<script>
    STYLE = 'width: 4em; margin-left: 1em;'     //  Style of the input text fields
    var configuratorString;
    openStrongTag = ''
    openTags = []

    tag = ''
    word = ''
    inTags = false
    elems = []

    state = 'none'
    ddbName = ''
    comment = ''
    varName = ''
    value = []
    options = []
    type = ''

    ddbDivs = []
    id = 0

    class DdbDiv {
        constructor(name) {
            this.name = name
            this.varNames = []
            this.comments = []
            this.values = []
            this.options = []
            this.types = []

            this.html = ''

            this.default = ''
        }

        addElement(varName_, comment_, value_, options_, type_) {
            this.varNames.push(varName_)
            this.comments.push(comment_)
            this.values.push(value_)
            this.options.push(options_)
            this.types.push(type_)
        }

        show() {
            let IDstring = ''
            this.html = '<div id="' + id + '">\n\t<h1>' + this.name + '</h1>'
            for (i = 0; i < this.varNames.length; i++) {
                let min = 0, max = 0, value = 0, step = 0, k = 0

                this.html += '<b>' + this.varNames[i] + '</b><br /><i>' + this.comments[i] + '</i><br />'

                switch (this.types[i]) {
                    case 'normal':
                        for (j = 0; j < this.values[i].length; j++) {
                            IDstring = id + '_input_' + j
                            this.html += '<input id="' + IDstring + '" type="number" value=' + this.values[i][j] + ' step="' + getStep(this.values[i][j]) + '" style="' + STYLE + '"></input>'
                        }
                        break
                    case 'combobox':
                        for (j = 0; j < this.values[i].length; j++) {
                            IDstring = id + '_input_' + j
                            this.html += '<select id="' + IDstring + '" style="' + STYLE + '">'
                            this.html += '<option value="' + this.values[i][j] + '" hidden>' + this.values[i][j] + '</option>'
                            for (k = 0; k < this.options[i].length; k++) this.html += '<option value="' + this.options[i][k] + '">' + this.options[i][k] + '</option>'
                            this.html += '</select>'
                        }
                        break
                    case 'labelled':
                        for (j = 0; j < this.values[i].length; j++) {
                            IDstring = id + '_input_' + j
                            this.default = this.options[i][0][1]
                            for (k = 0; k < this.options[i].length; k++) if (this.values[i][j] == this.options[i][k][0]) this.default = this.options[i][k][1]

                            this.html += '<select id="' + IDstring + '" style="' + STYLE + '">'
                            this.html += '<option value="' + this.default + '" hidden>' + this.default + '</option>'
                            for (k = 0; k < this.options[i].length; k++) this.html += '<option value="' + this.options[i][k][1] + '">' + this.options[i][k][1] + '</option>'
                            this.html += '</select>'
                        }
                        break
                    case 'length':
                        IDstring = id + '_input_0'
                        this.html += '<input id="' + IDstring + '" value="' + this.values[i][0] + '" type="text" maxlength="' + this.options[i][0] + '" />'
                        break
                    case 'checkbox':
                        IDstring = id + '_input_0'
                        this.html += '<input id="' + IDstring + '" type="checkbox"'
                        if (this.values[i][0] == 'true') this.html += ' checked'
                        this.html += '/>'
                        break
                    case 'maxvalue':
                        IDstring = id + '_input_0'
                        max = this.options[i][0]
                        value = this.values[i][0]
                        this.html += '<input id="' + IDstring + '" type="range" min="0" max="' + max + '" value="' + value + '" oninput="document.getElementById(\'' + IDstring + '_text\').value = document.getElementById(\'' + IDstring + '\').value" />'
                        this.html += '<input id="' + IDstring + '_text" type="number" min="0" max="' + max + '" value="' + value + '" step="' + getStep(this.values[i][0]) + '" oninput=\'document.getElementById("' + IDstring + '").value = document.getElementById("' + IDstring + '_text").value\' style="' + STYLE + '"/>'
                        break
                    case 'range':
                        IDstring = id + '_input_0'
                        min = this.options[i][0]
                        max = this.options[i][1]
                        value = this.values[i][0]
                        this.html += '<input id="' + IDstring + '" type="range" min="' + min + '" max="' + max + '" value="' + value + '" oninput=\'document.getElementById("' + IDstring + '_text").value = document.getElementById("' + IDstring + '").value\' />'
                        this.html += '<input id="' + IDstring + '_text" type="number" min="' + min + '" max="' + max + '" value="' + value + '" step="' + getStep(this.values[i][0]) + '" oninput=\'document.getElementById("' + IDstring + '").value = document.getElementById("' + IDstring + '_text").value\' style="' + STYLE + '"/>'
                        break
                    case 'rangestep':
                        IDstring = id + '_input_0'
                        min = this.options[i][0]
                        step = this.options[i][1]
                        max = this.options[i][2]
                        value = this.values[i][0]
                        this.html += '<input id="' + IDstring + '" type="range" min="' + min + '" step="' + step + '" max="' + max + '" value="' + value + '" oninput=\'document.getElementById("' + IDstring + '_text").value = document.getElementById("' + IDstring + '").value\' />'
                        this.html += '<input id="' + IDstring + '_text" type="number" min="' + min + '" max="' + max + '" value="' + value + '" step="' + step + '" oninput=\'document.getElementById("' + IDstring + '").value = document.getElementById("' + IDstring + '_text").value\' style="' + STYLE + '"/>'
                        break
                    default: break
                }
                this.html += '<br /><br />'
                id++
            }
            this.html = this.html + '</div>'

            document.getElementById('container').innerHTML += this.html
        }
    }

    function getStep(val) {
        str = val.toString().split('.')

        if (str.length == 1) return 1
        else return 1 / (10 ** str[1].length)
    }

    async function parse_text_as_scad() {
        await $('#configurator').show();
        await updateFileSelector("main.scad");

        text = await window.editor.getValue();
        index = 0
        elems = []

        while (index < text.length) {
            if (text[index] == '\n') {
                index = index + 1
                continue
            }

            nIndex = text.indexOf('\n', index)
            if (nIndex == -1) nIndex = text.length

            parse_line(text.substring(index, nIndex))

            index = nIndex + 1
        }

        interpret_elems()

        document.getElementById("container").innerHTML = ''
        id = 0
        for (I = 0; I < ddbList.length; I++) ddbList[I].show()
    }

    async function generate_param_string() {
        alert("doingThatThing");
        $('#configurator').hide();
        let parameterSet = { "parameterSets": { "FirstSet": {} } }

        let IDString = ''
        let valString = ''
        let tmp = ''
        id = 0
        for (i = 0; i < ddbList.length; i++) {
            varNames = ddbList[i].varNames;
            values = ddbList[i].values;
            types = ddbList[i].types;
            options = ddbList[i].options;
            for (j = 0; j < types.length; j++) {
                valString = ''
                if (values[j].length > 1) valString += '['
                if (types[j] == 'checkbox') valString += document.getElementById(id + '_input_0').checked
                else if (types[j] == 'labelled') {
                    for (k = 0; k < values[j].length; k++) {
                        IDString = id + '_input_' + k
                        tmp = document.getElementById(IDString).value
                        for (l = 0; l < options[j].length; l++) {
                            if (options[j][k][1] == tmp) {
                                valString += options[j][k][0]
                                break
                            }
                        }
                        if (k != values[j].length - 1) valString += ', '
                    }
                }
                else {
                    for (k = 0; k < values[j].length; k++) {
                        IDString = id + '_input_' + k
                        valString += document.getElementById(IDString).value
                        if (k != values[j].length - 1) valString += ', '
                    }
                }
                if (values[j].length > 1) valString += ']'

                parameterSet["parameterSets"]["FirstSet"][varNames[j]] = valString

                id++
            }
        }

        console.log(JSON.stringify(parameterSet))
        alert(JSON.stringify(parameterSet))
        configuratorString = await JSON.stringify(parameterSet);

    }

    function parse_line(line) {
        OPENING_TAGS = ['/*', '[']
        CLOSING_TAGS = ['*/', ']']
        STRONG_OPENING_TAGS = ['"']             //  These are tags in which no other tags can be opened. For example, you cannot open a comment with // inside a string.
        STRONG_CLOSING_TAGS = ['"']
        SYMBOLS = ['=', ';', ':', ',', '//']

        for (i = 0; i < line.length; i++) {
            inTags = false;
            tag = tag + line[i]

            if (openStrongTag != '') {
                closingTag = findClosingTag()

                if (closingTag.includes(tag)) {
                    inTags = true
                    if (closingTag == tag) {
                        openStrongTag = ''
                        pushWordAndTag()
                    }
                } else {
                    word = word + line[i]
                    tag = '';
                }
            } else {
                for (j = 0; j < STRONG_OPENING_TAGS.length; j++)
                    if (STRONG_OPENING_TAGS[j] == tag) {
                        openStrongTag = STRONG_OPENING_TAGS[j]
                        pushWordAndTag()
                    }

                closingTag = ''
                if (openTags.length != 0) {
                    openTag = openTags[openTags.length - 1]
                    for (j = 0; j < OPENING_TAGS.length; j++)
                        if (OPENING_TAGS[j] == openTag)
                            closingTag = CLOSING_TAGS[j]
                }

                for (j = 0; j < OPENING_TAGS.length; j++) {
                    if (tag == closingTag && closingTag != '') {
                        openTags.pop()
                        pushWordAndTag()
                        break;
                    }
                    if (OPENING_TAGS[j].includes(tag)) {
                        inTags = true;
                        if (OPENING_TAGS[j] == tag) {
                            openTags.push(OPENING_TAGS[j])
                            pushWordAndTag()
                        }
                    }
                    if (CLOSING_TAGS[j].includes(tag)) inTags = true;
                }

                if (inTags == false) {
                    for (j = 0; j < SYMBOLS.length; j++) {
                        if (SYMBOLS[j].includes(tag)) {
                            inTags = true
                            if (SYMBOLS[j] == tag) pushWordAndTag()
                        }
                    }
                }
            }
            if (inTags == false) {
                if (tag != ' ') word = word + tag
                else pushWord()
                tag = '';
            }
        }
        pushWord()
        elems.push('\n')
    }

    function findClosingTag() {
        for (j = 0; j < STRONG_OPENING_TAGS.length; j++)
            if (STRONG_OPENING_TAGS[j] == openStrongTag)
                return STRONG_CLOSING_TAGS[j]
        return ''
    }

    function pushWord() {
        if (word.length != 0) {
            elems.push(word)
            word = ''
        }
    }

    function interpret_elems() {
        reset_interpreter()
        ddbList = []

        for (i = 0; i < elems.length; i++) {
            if (elems[i] == '/*' && elems[i + 1] == '[' && state == 'none') {
                state = 'ddb'
                i = i + 1
            } else if (elems[i] == '/*') {
                state = 'longcomment'
            } else if (elems[i] == '*/' && state == 'longcomment') state = 'none'
            else if (elems[i] == ']' && elems[i + 1] == '*/' && state == 'ddb') {
                state = 'none'
                i = i + 1
                ddbList.push(new DdbDiv(ddbName))
                ddbName = ''
            } else if (state == 'ddb') ddbName = ddbName + elems[i]
            else if (state == 'none' && elems[i] == '//') {
                if (i == 0) state = 'comment'
                else if (elems[i - 1] == '\n') state = 'comment'
            } else if (state == 'comment' && elems[i] != '\n') {
                if (comment == '') comment = elems[i]
                else comment = comment + ' ' + elems[i]
            } else if (state == 'comment' && elems[i] == '\n') {
                state = 'equal'
                varName = elems[i + 1]
            } else if (state == 'equal' && elems[i] == '=') state = 'value'
            else if (state == 'value') {
                if (elems[i] == '[') state = 'value_array'
                else {
                    if (elems[i] == '"') {
                        value.push(elems[i + 1])
                        i = i + 2
                    } else if (elems[i] == 'true' || elems[i] == 'false') {
                        type = 'checkbox'
                        value.push(elems[i])
                        pushToDDB()
                        continue
                    }
                    else value.push(elems[i])
                    state = 'semicolon'
                }
            } else if (state == 'value_array') {
                if (elems[i] == ']') {
                    state = 'semicolon'
                }
                else if (elems[i] != ',' && elems[i] != '"') value.push(elems[i])
            } else if (state == 'semicolon') {
                if (elems[i] == ';') {
                    state = 'options'
                }
            } else if (state == 'options') {
                if (elems[i] == '\n') {
                    type = 'normal'
                    pushToDDB()
                }
                else if (elems[i] == '[') state = 'options['
                else if (!isNaN(elems[i])) {
                    type = 'length'
                    options.push(elems[i])
                    pushToDDB()
                }
            } else if (state == 'options[') {
                if (elems[i + 1] == ',') {
                    type = 'combobox'
                    let tmp = ''
                    while (true) {
                        if (elems[i] == ',') {
                            pushOption(tmp.substring(0, tmp.length - 1))
                            tmp = ''
                            i = i + 1
                            continue
                        }
                        else if (elems[i] == ']') {
                            pushOption(tmp.substring(0, tmp.length - 1))
                            tmp = ''
                            break
                        }
                        else {
                            tmp += elems[i] + ' '
                            i = i + 1
                        }
                    }
                }
                else if (elems[i + 1] == ']') {
                    if (!isNaN(elems[i])) type = 'maxvalue'
                    else type = 'combobox'
                    pushOption(elems[i])
                }
                else if (elems[i + 1] == ':' && elems[i + 3] == ':' && !isNaN(elems[i]) && !isNaN(elems[i + 2]) && !isNaN(elems[i + 4])) {
                    type = 'rangestep'
                    pushOption(elems[i])
                    pushOption(elems[i + 2])
                    pushOption(elems[i + 4])
                    i = i + 4
                }
                else if (elems[i + 1] == ':' && elems[i + 3] == ']') {
                    type = 'range'
                    pushOption(elems[i])
                    pushOption(elems[i + 2])
                    i = i + 2
                }
                else if (elems[i + 1] == ':') {
                    type = 'labelled'
                    while (elems[i + 1] == ':') {
                        pushOptionList(elems[i], elems[i + 2])
                        i = i + 3
                        if (elems[i] == ',') i = i + 1
                        else break;
                    }
                }
                if (elems[i] == ']') pushToDDB()
            }
        }
    }

    function pushWordAndTag() {
        pushWord()
        elems.push(tag)
        tag = ''
    }

    function pushOption(e) {
        if (!isNaN(e)) options.push(parseFloat(e))
        else options.push(e)
    }

    function pushOptionList(e1, e2) {
        if (!isNaN(e1)) e1 = parseFloat(e1)
        if (!isNaN(e2)) e2 = parseFloat(e2)
        options.push([e1, e2])
    }

    function pushToDDB() {
        if (ddbList.length == 0) ddbList.push(new DdbDiv(ddbName))
        ddbList[ddbList.length - 1].addElement(varName, comment, value, options, type)
        reset_interpreter()
    }

    function reset_interpreter() {
        state = 'none'
        ddbName = ''
        comment = ''
        varName = ''
        value = []
        options = []
        type = ''
        while (elems[i] != '\n') i++
    }
</script>